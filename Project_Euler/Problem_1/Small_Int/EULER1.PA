///////////////////////////////
/ PROJECT EULER #1
/ JEREMY PASTIN
/ 2-25
/ PAL8 ASSEMBLY
///////////////////////////////

*0200				/START AT PAGE 1
///
/INITIALIZE SYMBOLS
///

/EAE INSTRUCTIONS - PAL8 NEEDS EAE INSTRUCTIONS DEFINED
DVI=	7407			/DIVIDE
MUY=	7405			/MULTIPLY

/MACROS
CLR=	CLA CLL			/CLEAR AC AND L 

/
/DEFINE VARIABLES
/

/VARIABLES
CNTR,	-1747			/LOOP CONTROL VARIABLE (SET 
				/ TO 999(DEC)
A,	3			/FIRST DIVISOR
B,	5			/SECOND DIVISOR
DVDND,	0			/DIVIDEND
RET,	0			/RETURN VALUE
ARR,	.; 0; 0; 0; 0; 0	/ARRAY OF CHARACTER CODES 
				/ FOR OUTPUT
ARRLEN, 4			/LENGTH OF PRECEDING ARRAY
TOTAL,	.; "T; "O; "T; 		/CHARACTER STRING TO SAY 
	"A; "L; ":; " ; 0	/ "TOTAL"

///
/BEGIN MAIN EXECUTION
///

	/WRITE THE WORD "TOTAL" OUT TO THE TTY
	TAD TOTAL		/LOAD THE ADDRESS OF TOTAL 
				/ INTO AC
	DCA STRING		/DEPOSIT INTO THE INPUT FOR 
				/ THE SUBROUTINE

	JMS OUTSTR		/JUMP TO THE STRING OUTPUT 
				/ SUBROUTINE


LOOP,	NOP			/START THE LOOP

	/
	/CHECK IF THE TOTAL EXCEEDS 1024(DEC) AND OUTPUT TO 
	/ TTY IF IT DOES.  THIS RESETS THE TOTAL

	CLR			/CLEAR AC & L
	TAD (2000)		/ADD 1024(DEC) TO AC
	CIA			/COMPLEMENT AND INVERT
	TAD SUM			/ADD SUM
	SMA 			/SKIP IF AC < 0
	JMS SUMPLS		/JUMP TO THE SUM PLUS 
				/ SUBROUTINE
	


	/
	/PROCESS FIRST DIVISOR
	/

	/LOAD DIVISOR	
	CLR			/CLEAR AC & L
	TAD A			/LOAD FIRST DIVISOR INTO AC
	DCA DVSR		/DEPOSIT INTO DIVISOR 

	/LOAD DIVIDEND
	CLR			/CLEAR AC & L
	TAD CNTR		/LOAD CNTR INTO AC
	CIA			/INVERT AC
	DCA DVDND		/DEPOSIT INTO DIVIDEND

	/PERFORM MODULO
	DCA RET			/LOAD 0 INTO RET
	JMS MODULO		/GO TO THE MODULO 
				/ SUBROUTINE

	/IF REMAINDER WAS ZERO, ADD TO SUM
	CLR
	TAD RET			/LOAD RET INTO AC
	SNA			/IF RET != 0		
	
	JMS AD2SUM		/GO TO THE SUM SUBROUTINE

	/IF REMAINDER WAS ZERO, SKIP PROCESSING SECOND 
	/ DIVISOR THIS AVOIDS DOUBLE COUNTING NUMBERS THAT 
	/ ARE MULTIPLES OF 15

	/LOOP CONTROL WORK (CONDITIONAL)
	CLR			/CLEAR AC & L
	TAD RET			/LOAD RET INTO AC
	SNA			/IF RET != 0
	ISZ CNTR		/INCREMENT THE COUNTER
	SNA			/IF RET != 0
	JMP LOOP		/SKIP THE REST OF THE LOOP

	/
	/PROCESS SECOND DIVISOR (B)
	/

	/LOAD DIVISOR
	CLR
	TAD B			/LOAD FIRST DIVISOR INTO AC
	DCA DVSR		/DEPOSIT INTO DIVISOR 

	/LOAD DIVIDEND
	CLR			/CLEAR AC & L
	TAD CNTR		/LOAD CNTR INTO AC
	CIA			/INVERT AC
	DCA DVDND		/DEPOSIT INTO DIVIDEND

	/PERFORM MODULO
	DCA RET			/LOAD 0 INTO RET
	JMS MODULO		/GO TO THE MODULO 
				/ SUBROUTINE

	/IF REMAINDER WAS ZERO, ADD TO SUM
	CLR
	TAD RET			/LOAD RET INTO AC
	SNA			/IF RET != 0		
	
	JMS AD2SUM		/GO TO THE SUM SUBROUTINE
		


	/LOOP CONTROL WORK
	CLR
	ISZ CNTR		/INCREMENT CNTR & SKIP JMP 
				/ IF 0
	JMP LOOP		/GO TO THE BEGINNING OF THE 
				/ LOOP

	/
	/DISPLAY THE RESULT ON THE TTY
	/
	CLR			/CLEAR AC & L
	JMS OCT2DEC		/CONVERT THE RESULT TO A 
				/ DECIMAL CHARACTER SET
	CLR			/CLEAR AC & L
	TAD ARR			/LOAD THE ADDRESS OF THE 
				/ OUTPUT STRING
	DCA STRING		/DEPOSIT INTO THE INPUT FOR 
				/ THE SUBROUTINE
	JMS OUTSTR		/JUMP TO THE STRING OUTPUT 
				/ SUBROUTINE
	

	JMP 7600

PAGE 
///
/SUBROUTINE DEFINITION
///

/
/RETURNS 1 IF DIVIDEND % DIVISOR = 0
/
MODULO,	0
	/CLEAR REGISTERS
	CLR			/CLEAR AC & L
	MQL			/CLEAR MQ

	/POPULATE DIVIDEND
	TAD	DVDND		/LOAD DIVIDEND INTO AC
	MQL			/LOAD DIVIDEND INTO MQ

	/PERFORM DIVISION
	DVI			/DIVIDE MQ
DVSR,	0			/DEFINE DIVISOR

	/SET UP RETURN VALUE
	SZA			/SKIP IF REMAINDER IS 0
	CLA IAC			/SET RETURN VALUE TO 1
	DCA RET			/DEPOSIT TO RET

	/RETURN TO CALLER
	JMP I	MODULO		/RETURN

/
/ADDS CURRENT NUMBER TO SUM
/
AD2SUM,	0
/SUBROUTINE VARIABLES
SUM,	0			/RUNNING TOTAL

	/CLEAR REGISTERS
	CLR			/CLEAR AC & L

	/SUM THE DIVIDEND WITH THE PREVIOUS SUM
	TAD CNTR		/LOAD CNTR INTO AC
	CIA			/INVERT THE COUNTER
	TAD SUM			/ADD THE SUM
	DCA SUM			/DEPOSIT INTO SUM

	/RETURN TO CALLER
	JMP I AD2SUM		/RETURN



/
/CONVERTS AN OCTAL NUMBER TO A DECIMAL CHARACTER STRING
/
OCT2DEC,0

/SUBROUTINE VARIABLES
CURPOS, 0			/POSITION OF CURRENT ARRAY 
				/ ELEMENT
CURADD,	0			/ADDRESS OF CURRENT ARRAY 
				/ ELEMENT
LCNTR,  0			/LOCAL LOOP COUNTER
MUCNTR,	0			/MULTIPLICATION LOOP 
				/ COUNTER
MUCND, 1			/INITIAL MULTIPLACAND

	
	/CLEAR  REGISTERS
	CLR			/CLEAR AC & L
	MQL			/LOAD AC TO MQ

	/DEFINE THE LOCAL LOOP COUNTER
	TAD ARRLEN		/LOAD THE ARRAY LENGTH INTO 
				/ AC
	CIA			/INVERT AND COMPLEMENT IT
	DCA LCNTR		/DEPOSIT INTO COUNTER
LLOOP,	NOP
	CLR			/CLEAR AC & L

	/DEFINE THE CURRENT ELEMENT
	TAD ARRLEN		/ADD THE LENGTH OF THE 
				/ ARRAY
	TAD LCNTR		/ADD THE LOOP COUNTER (THIS 
				/ IS NEGATIVE)
	DCA CURPOS		/DEPOSIT INTO CURPOS

	/DEFINE THE ADDRESS OF THE CURRENT ELEMENT
	TAD ARR			/LOAD THE ADDRESS OF THE 
				/ ARRAY
	IAC			/INCREMENT TO THE FIRST 
				/ ELEMENT OF THE ARRAY
	TAD CURPOS		/ADD THE POSITION OF THE 
				/ CURRENT ELEMENT
	DCA CURADD		/DEPOSIT INTO CURADD

	/
	/DEFINE THE DIVISOR AS THE CORRECT POWER OF 10(DEC)
	/
	/CREATE THE COUNTER FOR THE MULTIPLICATION LOOP

	TAD LCNTR		/LOAD THE LOOP COUNTER
	IAC			/INCREMENT AC, WE WANT TO 
				/ END WITH ZERO
	DCA MUCNTR		/DEPOSIT IT AS THE 
				/ MULTIPLICATION LOOP 
				/ COUNTER

	/START WITH A MULTIPLICAND OF 1
	IAC			/LOAD 1 INTO AC
	DCA MUCND		/DEPOSIT INTO MUCND 
				/ (MULTIPLICAND)

	/RETRIEVE THE CORRECT POWER OF 10(DEC)
	JMS MULTIP		/GO TO MULTIPLICATION 
				/ SUBROUTINE

	/MULTIPLICAND ALWAYS NEEDS TO BE AT LEAST ONE
	CLR
	TAD MUCND		/LOAD MUCND INTO AC
	SNA			/SKIP IF NON-ZERO
	IAC			/ADD 1
	DCA MUCND		/DEPOSIT INTO MUCND

	/
	/DIVIDE THE INPUT AND STORE THE QUOTIENT IN THE 
	/ ARRAY
	/

	/DEFINE THE DIVISOR
	CLR			/CLEAR AC & L
	TAD MUCND		/LOAD THE MULTIPLACAND 
				/ PREVIOUSLY CALCULATED
	DCA LDVSR		/DEPOSIT INTO LDVSR

	/DO THE DIVISION
	CLR			/CLEAR AC & L
	MQL			/CLEAR MQ
	TAD SUM			/LOAD THE CURRENT SUM INTO 
				/ THE ACCUMULATOR
	SWP			/PUT THE SUM INTO MQL
	DVI			/DIVIDE
LDVSR,0				/BY THE CORRECT POWER OF 
				/ 10(DEC)
	DCA SUM			/STORE THE REMAINDER AS THE 
				/ NEW SUM
	SWP			/PULL THE QUOTIENT FROM MQ 
				/ INTO AC
	TAD (260)		/ADD OFFSET TO CHARACTER 
				/ CODE FOR 0
	DCA I CURADD		/DEPOSIT INTO CURRENT 
				/ ADDRESS


	/LOOP CONTROL
	ISZ LCNTR		/IF LCNTR IS 0 EXIT
	JMP LLOOP		/ITERATE THE LOOP

	JMP I OCT2DEC		/RETURN TO CALLER
/
/RETURNS A POWER OF 10(DEC) BASED ON COUNTER INPUT
/
MULTIP, 0
MULOOP,	NOP
	/CLEAR THE REGISTERS
	CLR			/CLEAR AC & L
	MQL			/CLEAR MQ
	
	/DO THE MULTIPLICATION
	TAD MUCND		/LOAD MUCND INTO AC
	MQL			/LOAD AC INTO MQL
	MUY			/MULTIPLY
MLTPLR,	12			/BY 10(DEC)
	SWP			/SWAP AC AND MQ
				/ ALL OF OUR PRODUCTS WILL 
				/ BE LESS THAN 12 BITS, SO 
				/ WE CAN IGNORE THE AC 
				/ PART OF THE RESULT
	DCA MUCND		/DEPOSIT THIS INTO 
				/ MULTIPLICAND

	/LOOP CONTROL
	ISZ MUCNTR
	JMP MULOOP
	JMP I MULTIP

/
/OUTPUTS A STRING TO THE TTY
/
OUTSTR,	0

/SUBROUTINE VARIABLES
STRING,	0			/ADDRESS OF THE STRING TO 
				/ PRINT
AIX1=	10			/THE FIRST AUTOINDEX 
				/ REGISTER

	CLR			/CLEAR AC & L
	TAD STRING		/LOAD THE FIRST WORD OF THE 
				/ STRING WHICH IS THE 
				/ ADDRESS OF THE STRING
	DCA AIX1		/DEPOSIT IT IN AUTOINDEX 
				/ REGISTER
	
OUTLP,	NOP

	TAD I AIX1		/INCREMENT AND LOAD THE 
				/ ADDRESS IN AIX1 TO AC
	SNA			/SKIP IF ADDRESS != 0
	JMP I OUTSTR		/JUMP BACK TO CALLER

	TLS			/WRITE AC TO TTY

	TSF			/WAIT FOR TTY TO BE READY
	JMP .-1			/TTY NOT READY, CHECK AGAIN

	CLR			/CLEAR AC & L
	JMP OUTLP		/JUMP TO TOP OF LOOP
	
/
/OUTPUTS THE CURRENT SUM ALONG WITH THE "+"
/
SUMPLS,	0

/SUBROUTINE VARIABLES
PLUS,	.			/STRING OF " + "
	" ; "+; " ; 0


	CLR			/CLEAR AC & L
	JMS OCT2DEC		/CONVERT THE CURRENT SUM TO 
				/ DECIMAL
	CLR			/CLEAR AC & L
	TAD ARR			/LOAD THE ADDRESS OF THE 
				/ OUTPUT STRING
	DCA STRING		/DEPOSIT INTO THE INPUT FOR 
				/ THE SUBROUTINE
	JMS OUTSTR		/JUMP TO THE STRING OUTPUT 
				/ SUBROUTINE

	CLR			/CLEAR AC & L
	TAD PLUS		/LOAD THE ADDRESS OF PLUS
				/ INTO AC
	DCA STRING		/DEPOSIT INTO THE INPUT FOR 
				/ THE SUBROUTINE
	JMS OUTSTR		/JUMP TO THE STRING OUTPUT 
				/ SUBROUTINE
	JMP I SUMPLS		/RETURN TO CALLER	
